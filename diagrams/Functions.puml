@startuml

interface Visitable{
+accept(v: Visitor): void
}
interface Visitor{
+visit(f: Function): void
+visit(p: Parameter): void
+visit(o: Operation): void
}

'TODO: Determine if visiting bottom classes is needed

class Printer implements Visitor{
+visit(f: Function): void
+visit(p: Parameter): void
+visit(o: Operation): void
}


interface Function extends Visitable{
+eval(): Number
}
class VariableFunction implements Function{
-variable: Parameter
+eval(): Number
}
class NonVariableFunction implements Function{
+eval(): Number
}

interface Parameter extends Visitable{
+setValue(p: Parameter): void
}

class MultipleParameter implements Parameter{
-parameters: List<Parameter>
}

class SingleParameter implements Parameter{
-representation: String
}

class Constant implements Parameter{
-value: Number
}

interface Operation extends Visitable{
+solve(p: Parameter): Number
}

abstract class UnaryOperation extends Operation{
-parameter: Parameter
+solve(p: Parameter): Number
}

abstract class BinaryOperation extends Operation{
-first: Parameter
-second: Parameter
+solve(p: Parameter): Number
}

class Addition extends BinaryOperation{
+solve(p: Parameter): Number
}
class Subtraction extends BinaryOperation{
+solve(p: Parameter): Number
}
class Multiplication extends BinaryOperation{
+solve(p: Parameter): Number
}
class Division extends BinaryOperation{
+solve(p: Parameter): Number
}
class Power extends BinaryOperation{
+solve(p: Parameter): Number
}

class AbsoluteValue extends UnaryOperation{
+solve(p: Parameter): Number
}
class SquareRoot extends UnaryOperation{
+solve(p: Parameter): Number
}





' Functions receive ONE WORD OR LETTER,
' then they are single-variable

' Extras
Visitable <-Visitor


@enduml